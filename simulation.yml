pdi:
  metadata:
    pcoord_1d: int
    pcoord: { type: array, subtype: int, size: 2 }
    psize: { type: array, subtype: int, size: 2 }
    dsize: { type: array, subtype: int, size: 2 }
    MaxtimeSteps: int
    timestep: int

  data:
    local_t:
      type: array
      subtype: double
      size: ['$dsize[0]', '$dsize[1]']
      subsize: ['$dsize[0] - 2', '$dsize[1] - 2']
      start: [1, 1]
    
  plugins:
#    trace:
    mpi:
    pycall:
      on_event:
        init_head:
          with: {rank: $pcoord_1d}
          exec: |
            import ray
            import subprocess
            if(rank==0):
                try:
                    subprocess.check_output(["ray", "start", "--head", "--resources='{\"reisa\": 100}'"])
                except:
                    pass


        init:
          with: {rank: $pcoord_1d, max: $MaxtimeSteps, dsize: $dsize}
          exec: |
            import ray
            import os
            import time

            filename="outputs/output_"+str(rank)+".txt" 
            mpi_per_node=int(os.environ.get("MPI_PER_NODE"))
            addr=os.environ.get("HN_ADDRESS").split(":")[0]
            clp=os.environ.get("CLIENT_PORT")

            def Derivee(F, dx):
                c0 = 2. / 3.
                dFdx = c0 / dx * (F[3: - 1] - F[1: - 3] - (F[4:] - F[:- 4]) / 8.)
                return dFdx
                        
            
            mpi = ray.init("ray://localhost:10001", namespace="mpi")
            print(mpi)


            ################################### Local Ray Instance Software #####################################
            # @ray.remote (num_cpus=0, resources={"reisa": 0.001})
            # class ProcessActor:
            #     def __init__(self):
            #         self.count = 0
                
            #     def add(self):
            #         self.count += 1
            #         return self.count

            #     def get_count(self):
            #         return self.count
                
            #     def iterate(self, iterA, gtA, pid):
            #         filename = "outputs/output_"+str(pid)+".txt"

            #         with ray.init("ray://"+addr+":"+clp, namespace="global", allow_multiple=True):
            #             @ray.remote (resources={'data': 0.01})
            #             def derivee_task(iter, gt):
            #                 try:
            #                     result = Derivee(gt, 1).mean()
            #                     with open(filename, "a") as f:
            #                         f.write("\nii = "+str(iter) \
            #                         + ", node = "+str(ray.get_runtime_context().get_node_id())\
            #                         + ", result = "+str(result)+"\n")
            #                 except:
            #                     print("Error occurred")
                            
            #                 return
                        
            #             derivee_task.remote(iterA, gtA)


            @ray.remote (resources={'data': 0.01})
            def derivee_task(iterD, gtD):
                try:
                    result = Derivee(gtD, 1).mean()
                    with open(filename, "a") as f:
                        f.write("\nii = "+str(iterD) \
                        + ", node = "+str(ray.get_runtime_context().get_node_id())\
                        + ", result = "+str(result)+"\n")
                except:
                    print("Error occurred")
                return
            
            @ray.remote (num_cpus=0, resources={"reisa": 0.001})
            def bridge_task(iter, gt):
                filename = "outputs/output_"+str(rank)+".txt"
                with ray.init("ray://"+addr+":"+clp, namespace="global", allow_multiple=True):
                    derivee_task.remote(iter, gt)
                return

            # if(rank % mpi_per_node == 0):
            #     actor = ProcessActor.options(name="count", lifetime="detached", namespace="mpi", max_concurrency=mpi_per_node).remote()
            # else:
            #     time.sleep(5)
            #     actor = ray.get_actor("count", namespace="mpi")

            # with open(filename, "a") as f:
            #     f.write("\nOut of the box P" + str(rank) + " my namespace is: "+str(ray.get_runtime_context().namespace) + " my actor is: "+str(actor))

        Available:
          with: { iter_id: $timestep, source_field: $local_t}
          exec: |
            bridge_task.remote(iter_id, ray.put(source_field))

        finish:
          exec: |
            time.sleep(30)
            # count = ray.get(actor.get_count.remote())
            # while(count != (max*mpi_per_node)):
            #     # with open(filename, "a") as f:
            #     #     f.write("\n"+str(count)+" != "+str(max*mpi_per_node)+"\n")
            #     time.sleep(2)
            #     continue
            with open(filename, "a") as f:
                f.write("\n\nFinished.")
