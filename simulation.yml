pdi:
  logging:
    level: "warn"

  metadata:
    pcoord_1d: int
    pcoord: { type: array, subtype: int, size: 2 }
    psize: { type: array, subtype: int, size: 2 }
    dsize: { type: array, subtype: int, size: 2 }
    MaxtimeSteps: int
    timestep: int

  data:
    local_t:
      type: array
      subtype: double
      size: ['$dsize[0]', '$dsize[1]']
      subsize: ['$dsize[0] - 2', '$dsize[1] - 2']
      start: [1, 1]
    
  plugins:
    mpi:
    pycall:
      on_event:
        init:
          with: {rank: $pcoord_1d, max: $MaxtimeSteps, dsize: $dsize}
          exec: |
            import os
            import ray
            import logging
            import reisa
            import time
            import socket

            # In this event we init ray, define all the tasks and create the actors
            
            np=int(os.environ.get("mpi_tasks")) # Number of processes
            mpi_per_node=int(os.environ.get("mpi_per_node")) # Number of processes per node
            concurrency=1

            
            ray.init(namespace="mpi", logging_level=logging.ERROR)
            if rank == 0:
                nodes = ray.nodes()
                this_node = socket.gethostname()

                for node in nodes:
                  if node["NodeManagerHostname"] == this_node:
                    cpus = int(node["Resources"]["CPU"])
                    concurrency = cpus-2
                    break
                print("Actor concurrency: "+str(concurrency))


            
            @ray.remote (max_task_retries=3, max_restarts=2, resources={"data":0})
            class FinishingActor:
                def __init__(self):
                    self.finished=False
                    self.count=0
              
                def finish(self):
                    self.finished=True
                
                def is_finished(self):
                    return self.finished
            
            @ray.remote (max_task_retries=3, max_restarts=2, resources={"data":0})
            class ProcessActor: 
                def __init__(self, f_actor):
                    self.results = {}
                    self.count = 0
                    self.f_actor=f_actor
                    for i in range(max):
                        self.results[i] = list()
                    return
                
                def add_result(self, iter, result):
                    i = int(iter)
                    self.results[i].append(result)
                    if len(self.results[i]) == np:
                        self.count = self.count+1
                        reisa.manageResults(self.results[i], i)
                        if(self.count==max):
                            self.f_actor.finish.remote()
                    return
            
            @ray.remote (max_retries=2, resources={"data":0})
            def analytics_task(mpid, data, iter, actor):
                # The task will be defined by the user, it will be executed in the workers, even the simulation is running.
                try:
                    result=reisa.analytics(mpid, data, iter)
                    result=iter
                    actor.add_result.remote(iter, result)
                except:
                    print("Error during analytics task.")
                return

            actor = None
            actorname = "ranktor"
            f_actor = None

            if rank == 0:
                f_actor = FinishingActor.options(max_concurrency=2, lifetime="detached").remote()
                actor = ProcessActor.options(max_concurrency=concurrency, name=actorname, namespace="mpi", lifetime="detached").remote(f_actor)

        declare:
          exec: |
            # This event is a synchronized point between initialization and iterations in order to get the actor handler
            if rank != 0:
                # The processes which have not created the actor look for it
                actor = ray.get_actor(actorname, namespace="mpi")
            
        
        Available:
          with: { i: $timestep, data: $local_t}
          exec: |
              # This event manages what is happening for each iteration
              analytics_task.remote(rank, ray.put(data), i, actor) # Task launching subtasksÂ¿?
              
        analyze:
          exec: |
            # Outside pycall, the rest of ranks are waiting
            if rank == 0:
                i = 0
                try:
                    while(not(ray.get(f_actor.is_finished.remote()))):
                        i = i+1
                except:
                    pass

        finish:
          exec: |
            # Just before this event there is a barrier, once the analytics are finished, the actors are destroyed and ray is terminated.
            if rank==0:
                ray.kill(f_actor)
                ray.kill(actor)
            ray.shutdown()
