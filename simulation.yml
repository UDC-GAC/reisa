pdi:
  logging:
    level: "warn"

  metadata:
    pcoord_1d: int
    pcoord: { type: array, subtype: int, size: 2 }
    psize: { type: array, subtype: int, size: 2 }
    dsize: { type: array, subtype: int, size: 2 }
    MaxtimeSteps: int
    timestep: int
    mpi_per_node: int

  data:
    local_t:
      type: array
      subtype: double
      size: ['$dsize[0]', '$dsize[1]']
      subsize: ['$dsize[0] - 2', '$dsize[1] - 2']
      start: [1, 1]
    
  plugins:
    mpi:
    pycall:
      on_event:
        init:
          with: {rank: $pcoord_1d, max: $MaxtimeSteps, dsize: $dsize, mpi_per_node: $mpi_per_node, psize: $psize}
          exec: |
            import ray
            import logging
            import time
            import os
            import netifaces

            # In this event we init ray, define all the tasks and create the actors
            ib = netifaces.ifaddresses('ib0')[netifaces.AF_INET][0]['addr']
            concurrency=int(mpi_per_node)+2

            ray.init(address="auto", namespace="mpi", logging_level=logging.ERROR, _node_ip_address=ib)
            # ray.timeline(filename="timeline-rank"+str(rank)+".json")

            
            @ray.remote (resources={"actor":1})
            class ProcessActor: 
                def __init__(self):
                    self.finished = False
                    self.queues = []
                    self.control = [0 for _ in range(max)]
                    for i in range(mpi_per_node):
                        self.queues.append([None for _ in range(max)]) # Levar conta das posici√≥ns usadas
                    return
                
                def is_finished(self):
                    while(not(self.finished)):
                        pass
                    return True

                def finish(self):
                    self.finished=True
                    return
                
                def add_value(self, mpid, result, iter):
                    iter=int(iter)
                    mpid=int(mpid)
                    self.queues[mpid%mpi_per_node][iter]=result[0]
                    self.control[iter] = self.control[iter]+1
                    return

                def trigger(self, remote_task, iter):
                    iter = int(iter)
                    while self.control[iter] < mpi_per_node:
                        pass    

                    tasks = []
                    for mpid in range(mpi_per_node):
                        tasks.append(remote_task.remote([self.queues[mpid][iter]], 0, iter))
                    return remote_task.remote(tasks, 1, iter)

            actor = None
            actorname = "ranktor"+str(rank - (rank%mpi_per_node))

            if rank%mpi_per_node == 0:
                actor = ProcessActor.options(max_concurrency=concurrency, name=actorname, namespace="mpi", lifetime="detached").remote()

        declare:
          exec: |
            # This event is a synchronization point between initialization and iterations in order to get the actor handler
            if rank%mpi_per_node != 0:
                # The processes which have not created the actor looks for it
                actor = ray.get_actor(actorname, namespace="mpi")

            put_time = 0.
            actor_time = 0.
            start = 0.
        
        Available:
          with: { i: $timestep, data: $local_t}
          exec: |
              # This event manages what is happening for each iteration
              if rank == 0:
                  start = time.time()
              d = ray.put(data)
              if rank == 0:
                  put_time = put_time + (time.time()-start)
                  start = time.time()
              
              status = ray.nodes()
              id = ray.get_runtime_context().get_node_id()
              flag = True
              while(flag):
                  for node in status:
                      if node['NodeID'] == id:
                          if node['Resources']['object_store_memory'] > 10**9:
                              flag = False
                          else:
                              break
                  status = ray.nodes()

              if rank%mpi_per_node == 0:
                  actor.add_value.remote(rank, [d], i)
                  actor_time = actor_time + (time.time()-start)
              else:
                  actor.add_value.remote(rank, [d], i)

        analyze:
          exec: |
            if rank == 0:
                print("{:<21}".format("PUT_TIME:") + str(put_time))
                print("{:<21}".format("SIM_BLOCK_TIME:") + str(actor_time))
                print("{:<21}".format("ACTOR_CONCURRENCY:") + str(concurrency))

            if rank%mpi_per_node == 0:
              ref = [actor.is_finished.remote()]
              while(True):
                  f, _ = ray.wait(ref, timeout=1)
                  if len(f)>0:
                      break
                  

        finish:
          exec: |
            ray.shutdown()
