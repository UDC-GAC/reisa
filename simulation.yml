pdi:
  metadata:
    pcoord_1d: int
    pcoord: { type: array, subtype: int, size: 2 }
    psize: { type: array, subtype: int, size: 2 }
    dsize: { type: array, subtype: int, size: 2 }
    MaxtimeSteps: int
    timestep: int

  data:
    local_t:
      type: array
      subtype: double
      size: ['$dsize[0]', '$dsize[1]']
      subsize: ['$dsize[0] - 2', '$dsize[1] - 2']
      start: [1, 1]
    
  plugins:
#    trace:
    mpi:
    pycall:
      on_event:
        init:
          with: {pcoord_1d: $pcoord_1d, max: $MaxtimeSteps, dsize: $dsize}
          exec: |
              import os
              import subprocess
              import time
              
              filename = "outputs/output_"+str(pcoord_1d)+".txt"
              addr=os.environ.get("RAY_ADDRESS").split(":")[0]
              # if(pcoord_1d == 0):
              #     try:
              #         resultado = subprocess.check_output(
              #             [
              #                 "ray",
              #                 "start",
              #                 "--address",
              #                 os.environ.get("RAY_ADDRESS"),
              #                 "--redis-password",
              #                 os.environ["redis_password"],
              #             ]
              #         )
              #         # Mostrar el código de salida, la salida estándar y la salida de error del proceso
              #     except:
              #         print("Ray start exception")
        declare:
          exec: |
            import ray
            import time

            ray.init()

            @ray.remote (resources={'mpi': 0.001})
            class ProcessActor: 
                def __init__(self):
                    self.count = 0
                    self.tasks = []

                def add(self):
                    self.count += 1
                    return self.count

                def get_count(self):
                    return self.count

                def killself(self):
                    ray.get(self.tasks)
                    del tasks
                    print(Killing)
                    ray.actor.exit_actor()
                
                def add_object(self, iter_id, a):
                    ob = ray.put(a)
                    ref = derivee_task.remote(iter_id, self, ob)
                    self.tasks.append(ref)
                    del ob
                    return ref

            def Derivee(F, dx):
                c0 = 2. / 3.
                dFdx = c0 / dx * (F[3: - 1] - F[1: - 3] - (F[4:] - F[:- 4]) / 8.)
                return dFdx
            
            @ray.remote (resources={'data': 0.001})
            def derivee_task(iter, actor: ray.actor.ActorHandle, gt):
                try:
                  result = Derivee(gt, 1).mean()
                  del gt
                  with open(filename, "a") as f:
                      f.write("\nii = " + str(iter)+", result = "+str(result)+"\n")
                except:
                  print("Error occurred")
                return
            
            actor = ProcessActor.options(name="ranktor"+str(pcoord_1d), lifetime="detached").remote()

        Available:
          with: { i: $timestep, source_field: $local_t}
          exec: |
            # subprocess.check_output(["ray", "memory", "--address", os.environ.get("RAY_ADDRESS")])
            ray.get(actor.add_object.remote(i, source_field))
            if i==(max-1):
                actor.killself.remote()
            
        finish:
          exec: |
            with open(filename, "a") as f:
                f.write("\n\nFinished.")
