pdi:
  metadata:
    pcoord_1d: int
    pcoord: { type: array, subtype: int, size: 2 }
    psize: { type: array, subtype: int, size: 2 }
    dsize: { type: array, subtype: int, size: 2 }
    MaxtimeSteps: int
    timestep: int

  data:
    local_t:
      type: array
      subtype: double
      size: ['$dsize[0]', '$dsize[1]']
      subsize: ['$dsize[0] - 2', '$dsize[1] - 2']
      start: [1, 1]
    
  plugins:
#    trace:
    mpi:
    pycall:
      on_event:

        init:
          with: {pcoord_1d: $pcoord_1d, max: $MaxtimeSteps, dsize: $dsize}
          exec: |
            import ray
            import os
            import time
            
            addr=os.environ.get("RAY_ADDRESS").split(":")[0]
            filename = "outputs/output_"+str(pcoord_1d)+".txt" 

            ray.init("ray://"+addr+":10001") # , _system_config={"infiniband": {"enabled": True}}")

            @ray.remote
            class ProcessActor:
                def __init__(self):
                    self.count = 0

                def add(self):
                    self.count += 1
                    return self.count

                def get_count(self):
                    return self.count

            def Derivee(F, dx):
                c0 = 2. / 3.
                dFdx = c0 / dx * (F[3: - 1] - F[1: - 3] - (F[4:] - F[:- 4]) / 8.)
                return dFdx
            
            @ray.remote (resources={'data': 0.01})
            def derivee_task(iter, actor: ray.actor.ActorHandle, gt):
                try:
                  result = Derivee(gt, 1).mean()

                  with open(filename, "a") as f:
                      f.write("\nii = " + str(iter)+", node = "+str(ray.get_runtime_context().get_node_id())+ ", result = "+str(result)+"\n")

                except:
                  print("Error occurred")

                actor.add.remote()

                return
            
            actor = ProcessActor.remote()

        Available:
          with: { iter_id: $timestep, source_field: $local_t}
          exec: |
            derivee_task.remote(iter_id, actor, ray.put(source_field))

        finish:
          exec: |
            import ray
            import time
            
            while(ray.get(actor.get_count.remote()) != max):
                time.sleep(2)
                continue
            with open(filename, "a") as f:
                f.write("\n\nFinished.")
            ray.shutdown()
